<script>
    (function () {
        'use strict';
        // Mock Data for Local Fallback
        const LOCAL_MOCK_DATA = [
            {
                id: '1',
                customerName: 'TechCorp GmbH (Local)',
                contactPerson: 'Julia M√ºller',
                email: 'julia.mueller@techcorp.de',
                eventDate: '2025-11-15',
                location: 'Berlin',
                status: 'LEAD'
            },
            {
                id: '2',
                customerName: 'Innovation Summit (Local)',
                contactPerson: 'Max Mustermann',
                email: 'max@innovation-summit.com',
                eventDate: '2026-03-20',
                location: 'M√ºnchen',
                status: 'FIX'
            }
        ];

        // Data Service Adapter
        const dataService = {
            getInquiries: async () => {
                return new Promise((resolve, reject) => {
                    if (typeof google === 'undefined') {
                        console.warn('GAS environment not detected. Using local mock data.');
                        setTimeout(() => resolve(LOCAL_MOCK_DATA), 500);
                    } else {
                        google.script.run
                            .withSuccessHandler(resolve)
                            .withFailureHandler(reject)
                            .getInquiries();
                    }
                });
            },

            getInquiryById: async (id) => {
                return new Promise((resolve, reject) => {
                    if (typeof google === 'undefined') {
                        const item = LOCAL_MOCK_DATA.find(i => i.id === id);
                        setTimeout(() => resolve(item), 200);
                    } else {
                        google.script.run
                            .withSuccessHandler(resolve)
                            .withFailureHandler(reject)
                            .getInquiryById(id);
                    }
                });
            }
        };

        // Application Logic
        window.currentInquiries = []; // Cache for navigation (Global access)

        document.addEventListener('DOMContentLoaded', () => {
            loadInquiries();
            document.getElementById('refresh-btn')?.addEventListener('click', loadInquiries);
        });

        async function loadInquiries() {
            const board = document.getElementById('kanban-board');
            if (board) board.innerHTML = '<div style="padding: 2rem; color: var(--text-muted);">Lade Daten...</div>';

            try {
                const inquiries = await dataService.getInquiries();
                window.currentInquiries = inquiries || [];
                if (board) renderKanban(inquiries);

                // If we are on the detail page, update nav buttons once data is loaded
                const currentId = document.getElementById('edit-id')?.value;
                if (currentId) updateNavButtonStates(currentId);
            } catch (error) {
                console.error('Error loading data:', error);
                if (board) board.innerHTML = '<div style="padding: 2rem; color: #ff6b6b;">Fehler beim Laden der Daten.</div>';
            }
        }

        /* --- NAVIGATION LOGIC --- */
        window.navigateEvent = (direction) => {
            const currentId = document.getElementById('edit-id').value;
            const currentIndex = window.currentInquiries.findIndex(item => item.id === currentId);

            if (currentIndex === -1) return;

            const nextIndex = currentIndex + direction;
            if (nextIndex >= 0 && nextIndex < window.currentInquiries.length) {
                openDetail(window.currentInquiries[nextIndex].id);
            }
        };

        window.updateNavButtonStates = (targetId) => {
            const currentIndex = window.currentInquiries.findIndex(item => item.id === targetId);
            const prevBtn = document.getElementById('prev-event-btn');
            const nextBtn = document.getElementById('next-event-btn');

            if (prevBtn) prevBtn.disabled = (currentIndex <= 0);
            if (nextBtn) nextBtn.disabled = (currentIndex === -1 || currentIndex >= window.currentInquiries.length - 1);
        }

        function renderKanban(inquiries) {
            const board = document.getElementById('kanban-board');
            board.innerHTML = '';

            // Safety Check
            if (!Array.isArray(inquiries)) {
                console.warn('renderKanban: inquiries is not an array', inquiries);
                inquiries = [];
            }

            // Define 4 active workflow columns
            const columns = [
                { id: 'REQUEST', title: 'Anfrage' },
                { id: 'OFFER', title: 'Angebot' },
                { id: 'FIX', title: 'Gebucht' },
                { id: 'BILLABLE', title: 'Abrechnung' }
            ];

            // Helper: Map status to column (with special rules)
            const getKanbanColumn = (item) => {
                const status = item.status;
                const eventDate = new Date(item.talkDate || item.eventDate);
                const isFuture = eventDate > new Date();

                // Status mapping rules
                if (status === 'RESERVED') return 'OFFER';
                if (status === 'PROBONO' && isFuture) return 'FIX';

                // Direct mapping for active workflow statuses
                if (['REQUEST', 'OFFER', 'FIX', 'BILLABLE'].includes(status)) {
                    return status;
                }

                // Hide all other statuses (LEAD, DECLINED, PAYED, SPECIAL, DELETE, DUPLICATE)
                return null;
            };

            // Group inquiries by column
            const grouped = {};
            columns.forEach(col => grouped[col.id] = []);

            inquiries.forEach(item => {
                const column = getKanbanColumn(item);
                if (column && grouped[column]) {
                    grouped[column].push(item);
                }
            });

            // Render columns
            columns.forEach(col => {
                const items = grouped[col.id];

                const colDiv = document.createElement('div');
                colDiv.className = 'kanban-col';

                colDiv.innerHTML = `
                <div class="kanban-header">
                    <span>${col.title}</span>
                    <span class="col-count">${items.length}</span>
                </div>
                <div class="kanban-body">
                    ${items.map(item => renderCard(item, col.id)).join('')}
                </div>
            `;
                board.appendChild(colDiv);
            });
        }

        function renderCard(item, colId) {
            // Format date
            const eventDateStr = item.talkDate || item.eventDate
                ? new Date(item.talkDate || item.eventDate).toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                })
                : 'TBD';

            // Status dropdown options
            const statusOptions = [
                { value: 'LEAD', label: 'LEAD' },
                { value: 'REQUEST', label: 'REQUEST' },
                { value: 'OFFER', label: 'OFFER' },
                { value: 'RESERVED', label: 'RESERVED' },
                { value: 'FIX', label: 'FIX' },
                { value: 'DECLINED', label: 'DECLINED' },
                { value: 'BILLABLE', label: 'BILLABLE' },
                { value: 'PAYED', label: 'PAYED' },
                { value: 'SPECIAL', label: 'SPECIAL' },
                { value: 'PROBONO', label: 'PROBONO' },
                { value: 'DELETE', label: 'DELETE' },
                { value: 'DUPLICATE', label: 'DUPLICATE' }
            ];

            const statusOptionsHtml = statusOptions.map(opt =>
                `<option value="${opt.value}" ${opt.value === item.status ? 'selected' : ''}>${opt.label}</option>`
            ).join('');

            // Generate unique ID for this card's select
            const selectId = `status-select-${item.id}`;

            return `
            <div class="kanban-card" style="cursor: pointer;">
                <div onclick="window.top.location.href='<?= ScriptApp.getService().getUrl() ?>?page=detail&id=${item.id}';" 
                     style="flex: 1;">
                    <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                        üìÖ ${eventDateStr}
                    </div>
                    <div class="card-title" style="margin-bottom: 0.25rem;">
                        ${item.event || 'TBD'}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--text-muted);">
                        ${item.location ? 'üìç ' + item.location : ''}
                    </div>
                </div>
                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
                    <select id="${selectId}" class="kanban-status-select" 
                            onchange="updateCardStatus('${item.id}', this.value, '${selectId}')" 
                            onclick="event.stopPropagation()">
                        ${statusOptionsHtml}
                    </select>
                </div>
            </div>
        `;
        }

        // Update status from Kanban card
        window.updateCardStatus = async (itemId, newStatus, selectId) => {
            try {
                await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .updateInquiry(itemId, { Status: newStatus });
                });
                console.log(`Status updated to ${newStatus} for ${itemId}`);
                // Reload to reflect changes
                loadInquiries();
            } catch (err) {
                alert('Fehler beim Aktualisieren des Status.');
                console.error(err);
                // Revert select
                const select = document.getElementById(selectId);
                if (select) select.value = select.dataset.originalValue || 'LEAD';
            }
        };

        /* --- EDITOR LOGIC --- */
        function autoResizeTextarea(el) {
            if (!el) return;
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        // Attach resize listeners to all textareas
        document.addEventListener('input', (e) => {
            if (e.target.tagName === 'TEXTAREA') {
                autoResizeTextarea(e.target);
            }
        });

        // Add update function to Service
        dataService.updateInquiry = async (id, updates) => {
            return new Promise((resolve, reject) => {
                if (typeof google === 'undefined') {
                    console.log('Mock Update:', id, updates);
                    // Mock local update
                    const idx = LOCAL_MOCK_DATA.findIndex(i => i.id === id);
                    if (idx !== -1) {
                        LOCAL_MOCK_DATA[idx] = { ...LOCAL_MOCK_DATA[idx], ...updates };
                    }
                    setTimeout(() => resolve({ success: true }), 500);
                } else {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .updateInquiry(id, updates);
                }
            });
        };

        window.toggleEditMode = (isEdit) => {
            const form = document.getElementById('edit-form');
            const editBtn = document.getElementById('edit-mode-btn');
            const viewActions = document.getElementById('view-actions');
            const editActions = document.getElementById('edit-actions');

            if (isEdit) {
                form.classList.remove('view-mode');
                editBtn.classList.add('hidden');
                viewActions.classList.add('hidden');
                editActions.classList.remove('hidden');
            } else {
                form.classList.add('view-mode');
                editBtn.classList.remove('hidden');
                viewActions.classList.remove('hidden');
                editActions.classList.add('hidden');
            }
        };

        window.openDetail = async (id) => {
            try {
                toggleEditMode(false); // Default to View Mode
                const item = await dataService.getInquiryById(id);
                if (!item) return alert('Datensatz nicht gefunden');

                // Helper to handle TBD fallback and Date formatting
                const tbd = (val, isDate = false) => {
                    if (val === undefined || val === null || String(val).trim() === '') return 'TBD';
                    if (isDate) {
                        // Remove seconds and timezone: "19:44:43 GMT+0100..." -> "19:44"
                        return String(val).replace(/(\d{2}:\d{2}):\d{2}.*$/, '$1');
                    }
                    return val;
                };

                // Populate Form
                document.getElementById('edit-id').value = item.id;
                document.getElementById('edit-date').value = tbd(item.talkDate, true);
                document.getElementById('edit-event').value = tbd(item.event);
                document.getElementById('edit-theme').value = tbd(item.theme);
                document.getElementById('edit-about-talk').value = tbd(item.aboutTalk);
                document.getElementById('edit-about-speaker').value = tbd(item.aboutSpeaker);
                document.getElementById('edit-audience-comp').value = tbd(item.audienceComposition);
                document.getElementById('edit-audience-size').value = tbd(item.audienceSize);
                document.getElementById('edit-language').value = item.language || 'TBD';
                document.getElementById('edit-fee').value = tbd(item.fee);
                document.getElementById('edit-payment').value = tbd(item.paymentDetails);
                document.getElementById('edit-expectations').value = tbd(item.expectations);
                document.getElementById('edit-ai-analysis').value = tbd(item.aiAnalysis);
                document.getElementById('edit-moderator').value = tbd(item.forModerator);
                document.getElementById('edit-tech').value = tbd(item.techRequirement);
                document.getElementById('edit-handout').value = tbd(item.handout);

                // Hotel Display & Link
                document.getElementById('edit-hotel').value = tbd(item.hotelDisplay);
                const hotelLink = document.getElementById('edit-hotel-link');
                if (item.hotelMapsLink) {
                    hotelLink.href = item.hotelMapsLink;
                    hotelLink.style.display = 'inline-block';
                } else {
                    hotelLink.style.display = 'none';
                }

                document.getElementById('edit-travel').value = tbd(item.travelPlan);
                document.getElementById('edit-entities').value = tbd(item.eventEntities);

                // Populate Top Status
                const statusTop = document.getElementById('edit-status-top');
                if (statusTop) {
                    statusTop.value = item.status || 'LEAD';

                    const statusColors = {
                        'LEAD': '#95a5a6', 'REQUEST': '#3498db', 'OFFER': '#9b59b6',
                        'RESERVED': '#f1c40f', 'FIX': '#2ecc71', 'DECLINED': '#e74c3c',
                        'BILLABLE': '#1abc9c', 'PAYED': '#7f8c8d', 'SPECIAL': '#e67e22', 'PROBONO': '#16a085', 'DELETE': '#95a5a6', 'DUPLICATE': '#e67e22'
                    };

                    const updateStatusStyle = (val) => {
                        const color = statusColors[val] || '#95a5a6';
                        statusTop.style.color = color;
                        statusTop.style.borderColor = color;
                        statusTop.style.background = `${color}10`;
                    };
                    updateStatusStyle(statusTop.value);

                    statusTop.onchange = async () => {
                        const newStatus = statusTop.value;
                        updateStatusStyle(newStatus);
                        try {
                            await dataService.updateInquiry(item.id, { Status: newStatus });
                            console.log('Status updated from detail top:', newStatus);
                        } catch (err) {
                            alert('Fehler beim Aktualisieren des Status.');
                        }
                    };
                }

                // Render Sources (Links)
                const sourcesContainer = document.getElementById('sources-links');
                if (sourcesContainer) {
                    sourcesContainer.innerHTML = '';
                    const links = (item.sources || '').split(',').map(l => l.trim()).filter(l => l);
                    if (links.length > 0) {
                        links.forEach((link, idx) => {
                            const a = document.createElement('a');
                            a.href = link;
                            a.target = '_blank';
                            a.className = 'detail-link';
                            a.style.display = 'block';
                            a.style.marginBottom = '4px';
                            a.innerHTML = `<i class="fa-solid fa-envelope"></i> E-Mail Quelle ${links.length > 1 ? idx + 1 : ''}`;
                            sourcesContainer.appendChild(a);
                        });
                    } else {
                        sourcesContainer.innerHTML = '<span class="tbd">Keine Quellen verkn√ºpft</span>';
                    }
                }

                // Render Contact Links for Entities
                const contactLinksContainer = document.getElementById('edit-contact-links');
                contactLinksContainer.innerHTML = '';

                try {
                    const entitiesRaw = item.eventEntities;
                    // Helper to parse if string
                    const tryPF = (v) => {
                        if (!v || v === 'TBD') return null;
                        if (typeof v === 'object') return v;
                        try { return JSON.parse(v); } catch (e) { return null; }
                    };

                    const entities = tryPF(entitiesRaw);
                    if (entities) {
                        const entityList = Array.isArray(entities) ? entities : [entities];
                        entityList.forEach(entity => {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'entity-display-item';

                            // 1. Organistion Typ as Label
                            const typeLabel = entity.Typ || 'Organisation';
                            let html = `<div class="entity-org-row"><span class="entity-type-label">${typeLabel}:</span> <span class="entity-org-name">${entity.Organisation || 'TBD'}</span></div>`;

                            // 2. Contacts as label + single line details
                            if (entity.Contacts && Array.isArray(entity.Contacts)) {
                                entity.Contacts.forEach(contact => {
                                    html += `<div class="entity-contact-row">`;
                                    html += `<span class="entity-contact-label">Kontakt:</span> `;
                                    html += `<span class="entity-contact-details">`;
                                    html += `<span class="contact-name-text">${contact.Name || ''}</span>`;

                                    if (contact.Email) {
                                        html += ` | <a href="mailto:${contact.Email}" class="contact-link">‚úâÔ∏è ${contact.Email}</a>`;
                                    }
                                    if (contact.Phone) {
                                        html += ` | <a href="tel:${contact.Phone}" class="contact-link">üìû ${contact.Phone}</a>`;
                                    }
                                    html += `</span></div>`;
                                });
                            }
                            wrapper.innerHTML = html;
                            contactLinksContainer.appendChild(wrapper);
                        });
                    }
                } catch (e) {
                    console.error('Error rendering contact links:', e);
                }

                document.getElementById('edit-referer').value = tbd(item.referer);
                document.getElementById('edit-kampagne').value = tbd(item.kampagne);
                document.getElementById('edit-todo').value = tbd(item.toDoList);
                document.getElementById('edit-final-title').value = tbd(item.finalTitle);
                document.getElementById('edit-title-suggestions').value = tbd(item.titleSuggestions);

                // Meta fields
                document.getElementById('edit-duration').value = item.duration || '';
                document.getElementById('edit-contact').value = item.contactPerson || '';
                document.getElementById('edit-location').value = item.location || '';
                document.getElementById('edit-notes').value = item.notes || '';

                // Update Navigation Button States
                updateNavButtonStates(id);

                // Show Modal
                document.getElementById('editor-modal').classList.remove('hidden');

                // Trigger auto-resize after population
                requestAnimationFrame(() => {
                    const textareas = document.querySelectorAll('#edit-form textarea');
                    textareas.forEach(autoResizeTextarea);
                });
            } catch (e) {
                console.error(e);
                alert('Fehler beim Laden der Details.');
            }
        };

        window.closeModal = () => {
            document.getElementById('editor-modal').classList.add('hidden');
        };

        window.saveChanges = async () => {
            const id = document.getElementById('edit-id').value;

            // Helper to reverse TBD
            const untbd = (id) => {
                const val = document.getElementById(id).value;
                return (val === 'TBD') ? '' : val;
            };

            const updates = {
                Talk_Date: untbd('edit-date'),
                Event: untbd('edit-event'),
                Final_Title: untbd('edit-final-title'),
                Title_Suggestions: untbd('edit-title-suggestions'),
                Theme: untbd('edit-theme'),
                About_Talk: untbd('edit-about-talk'),
                About_Speaker: untbd('edit-about-speaker'),
                Audience_Composition: untbd('edit-audience-comp'),
                Audience_Size: untbd('edit-audience-size'),
                Language: untbd('edit-language'),
                Netto_Fee: untbd('edit-fee'),
                Payment_Details: untbd('edit-payment'),
                Expections_of_Speaker: untbd('edit-expectations'),
                AI_Analysis: untbd('edit-ai-analysis'),
                For_Moderator: untbd('edit-moderator'),
                Tech_Requirement: untbd('edit-tech'),
                Handout: untbd('edit-handout'),
                Hotel: untbd('edit-hotel'),
                Travel_Plan: untbd('edit-travel'),
                Referer: untbd('edit-referer'),
                Kampagne: untbd('edit-kampagne'),
                Event_Entities: untbd('edit-entities'),
                ToDoList: untbd('edit-todo'),
                Status: document.getElementById('edit-status-top').value,
                Duration: document.getElementById('edit-duration').value,
                Notes: document.getElementById('edit-notes').value,
                Location: document.getElementById('edit-location').value
            };

            const btn = document.querySelector('#edit-actions .btn-primary');
            const originalText = btn.innerText;
            btn.innerText = 'Speichern...';
            btn.disabled = true;

            try {
                await dataService.updateInquiry(id, updates);
                toggleEditMode(false); // Back to View Mode
                loadInquiries(); // Refresh Board
                // Note: We might want to keep the modal open to show the new "View" state
                // but standard behavior here was closeModal. Let's stick to closing for now
                // to avoid confusion with stale data if the update takes time.
                closeModal();
            } catch (e) {
                alert('Fehler beim Speichern: ' + e.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        };

        // Close on outside click
        document.getElementById('editor-modal').addEventListener('click', (e) => {
            if (e.target.id === 'editor-modal') closeModal();
        });
    })();
</script>